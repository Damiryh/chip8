; #0200
    ld @10, #12	; X цифры
    ld @11, #01 ; Y цифры
    ld @1, #10  ; X плитки
    ld @2, #00  ; Y плитки
    ld @0, #00  ; Значение плитки
	

INIT_LOOP: ; #020a
    ld I, [tile]			; Загружаем адрес плитки в индекс
    drw @1, @2, !7			; Рисуем плитку
    ld F, @0				; Загружаем адрес спрайта цифры в индекс
    se @0, #00				; Если цифра на плитке - не нуль,
    drw @10, @11, !5		; То рисуем цифру
    add @1, #08				; Свигаем позицию плитки вправо
    add @10, #08			; Свигаем позицию цифры вправо
    se @1, #30				; Если не дошли до правого края
	
    jp [HORIZ]				; То пропускаем код перехода по вертикали
    ld @1, #10				; Сдвигаем плитку до конца влево
    add @2, #08				; Сдвигаем плитку вниз
    ld @10, #12				; Сдвигаем цифру до конца влево
    add @11, #08			; Сдвигаем цифру вниз
	

; Начиная с адреса #300 лежит массив значений плиток

HORIZ: ; #0224
    ld I, [#0300]	; Здесь вычисляем адрес текущей плитки
    add I, @0		; I = #300 + @0
    ld [I], @0		; Сохраняем в него значение плитки
    add @0, #01		; И идём к следующей
    se @0, #10  	; Пока не дошли до последней плитки
    jp [INIT_LOOP]	; Продолжаем отрисовку и заполнение таблицы

; #0230
    ld @10, #12	; Сбрасываем позицию цифры
    ld @11, #01	

; #0234
    ld @12, #00
; #0236
    ld @2, #ff		; Счётчик перемешиваний = 255


; #0238
    rnd @0, #06		; Генерируем случайные нажатия 
    add @0, #02		; На клавиши '2', '4', '6' и '8'
; #023c


    call [#0252]	; Вызываем подпрограмму вычисления новой позиции
    add @2, #ff		; Вычитаем единицу из счетчика (через переполнение)
; #0240
    se @2, #00		; Пока счётчик не обнулен
    jp [#0238]		; продоолжаем перемешивание

; #0244
    ld @14, #00
; #0246
    ld @14, #00


; #0248
    ld @0, K			; Принимаем ввод от игрока
; #024a
    call [#0252]		; Вызываем функцию вычисления новой позиции
; #024c
    add @14, #01		
; #024e
    add @14, #01
; #0250
    jp [#0248]			; Продолжаем



; #0252
    ld @4, @10		; Загружаем позицию цифры
    ld @5, @11		; В регистры @4 и @5

; #0256
    ld @6, @12		; Адрес текущей ячейки в таблице (?)


; #0258
    se @0, #02		; Если нажали 'вверх'
    jp [#0264]		; И
    sne @5, #01		; Y != 1
    jp [#0264]		
    add @5, #f8		; Двигаем цифру вверх
    add @6, #fc		; На строку вниз в таблице (?)


; #0264
    se @0, #08		; Если нажали 'вниз'
    jp [#0270]		; И
    sne @5, #19		; X != #19
    jp [#0270]
    add @5, #08		; Вниз на тайл
    add @6, #04		; На строку вниз в таблице


; #0270
    se @0, #06		; Если нажали 'вправо' (?)
    jp [#027c]		; И
    sne @4, #12		; X != #12
    jp [#027c]
    add @4, #f8		; Влево на тайл
    add @6, #ff		; На столбец влево в таблице

; #027c
    se @0, #04		; Если нажали 'влево'
    jp [#0288]		; И
    sne @4, #2a		; X != #2a
    jp [#0288]
    add @4, #08		; Вправо на тайл
    add @6, #01		; На столбец вправо в таблице




; #0288
    ld I, [#0300]	; Считаем адрес для новой позиции в памяти
    add I, @6		; I = #300 + @6
    ld @0, [I]		; Загружаем значение плитки по этому адресу

; #028e
    ld @1, @0		; Сохраняем значение передвигаемой плитки
    ld @0, #00		; В регистр @1, а @0 обнуляем
	
; #0292
    ld I, [#0300]	; Считаем адрес заново
    add I, @6		; I = #300 + @6
    ld [I], @0		; Загружаем на место предыдущей цифры нуль


; #0298
    ld I, [#0300]	; Считаем адрес исходной ячейки
    add I, @12		; I = #300 + @12
    ld @0, @1		; Возвращаем цифру в регистр @0
    ld [I], @0		; И записываем цифру в таблицу

; #02a0
    ld F, @1		; Загружаем адрес цифры в индекс
    drw @4, @5, !5	; Рисуем цифру на новом месте
    drw @10, @11, !5 ; И на старом (?)
; #02a6
    ld @10, @4		; Теперь пустая ячейка окажется на новом месте
    ld @11, @5 
    ld @12, @6		; Как и текущий адрес пустой ячейки в таблице
; #02ac
    ret				; Выходим из подпрограммы

; #02ae
    .db #ee, #5e


tile:
    .db #fe, #fe, #fe, #fe, #fe, #fe, #fe, #fe